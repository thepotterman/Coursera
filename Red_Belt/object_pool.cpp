#include "test_runner.h"

#include <algorithm>
#include <iostream>
#include <string>
#include <queue>
#include <stdexcept>
#include <set>

using namespace std;

/*
На практике часто возникают объекты, создание которых занимает значительное время, 
например, потоки (threads), TCP-соединения или подключения к базе данных. 
Поэтому, когда такой объект становится не нужен, его не разрушают, 
а откладывают в сторону, чтобы потом переиспользовать. 
В этой задаче вам предстоит реализовать такую схему — 
вам надо написать шаблон класса ObjectPool:

template <class T>
class ObjectPool {
public:
  T* Allocate();
  T* TryAllocate();

  void Deallocate(T* object);

  ~ObjectPool();

private:
  ...
};

Объект класса ObjectPool должен поддерживать два набора объектов: выделенные и освобождённые, — 
изначально оба набора пусты.

Метод Allocate должен работать так:

если есть хотя бы один освобождённый объект, 
то его надо перенести в множество выделенных и вернуть 
указатель на него в качестве результата функции

если же освобождённых объектов нет, то создаётся новый объект, 
помещается в множество выделенных, и указатель на него возвращается в качестве результата функции

Метод TryAllocate работает аналогично, однако если освобождённых объектов нет, 
он должен просто возвращать nullptr.

Метод Deallocate переносит объект из множества выделенных в множество освобождённых; 
если переданный объект не содержится в множестве выделенных, 
метод Deallocate должен бросать исключение invalid_argument.

Методы Allocate и TryAllocate должны возвращать объекты в порядке FIFO, 
т.е. множество освобождённых объектов должно представлять собой очередь: 
методы [Try]Allocate должны извлекать объекты из её начала, 
а метод Deallocate должен помещать освобождаемый объект в её конец.

Деструктор объекта ObjectPool должен уничтожать все объекты пула, как выделенные, так и освобождённые.

*/

template <class T>
class ObjectPool {
public:
    T* Allocate() {
        T* result;
        if(freed.size() != 0) {
            result = freed.front();
            freed.pop();
            alloted.insert(result);
        } else {
            result = new T;
            alloted.insert(result);
        }
        return result;
    }
    
    T* TryAllocate() {
        T* result = nullptr;
        if(freed.size() != 0) {
            result = freed.front();
            freed.pop();
            alloted.insert(result);
        }
        return result;
    }
    
    void Deallocate(T* object) {
        if(alloted.count(object) == 0) {
            throw invalid_argument("IA");
            return;
        }
        freed.push(object);
        alloted.erase(object);
    }
    
    ~ObjectPool() {
        while(freed.size() > 0) {
            T* cur = freed.front();
            freed.pop();
            delete cur;    
        }
        for(T* cur : alloted) {     
            delete cur;
        }
        alloted.clear();
    }
    
private:
      queue<T*> freed;
      set<T*> alloted;
};

void TestObjectPool() {
  ObjectPool<string> pool;

  auto p1 = pool.Allocate();
  auto p2 = pool.Allocate();
  auto p3 = pool.Allocate();

  *p1 = "first";
  *p2 = "second";
  *p3 = "third";

  pool.Deallocate(p2);
  ASSERT_EQUAL(*pool.Allocate(), "second");

  pool.Deallocate(p3);
  pool.Deallocate(p1);
  ASSERT_EQUAL(*pool.Allocate(), "third");
  ASSERT_EQUAL(*pool.Allocate(), "first");

  pool.Deallocate(p1);
}

int main() {
  TestRunner tr;
  RUN_TEST(tr, TestObjectPool);
  return 0;
}
